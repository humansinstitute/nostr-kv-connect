import { Keyring } from '../keys/keyring.js';
import { Config } from '../types.js';
import { bytesToHex } from '@noble/curves/abstract/utils';
import crypto from 'crypto';

export function generateTestURI(config: Config, serverKeyring: Keyring, useHex: boolean = true): string {
  // Generate a client keypair for testing
  const clientKeyring = new Keyring();
  
  // Build URI components
  const params = new URLSearchParams();
  
  // Add relays
  config.nostr.relays.forEach(relay => {
    params.append('relay', relay);
  });

  // Add client secret (use hex by default for better compatibility)
  const clientSecret = useHex ? bytesToHex(clientKeyring.getSecretKey()) : clientKeyring.getNsec();
  params.append('secret', clientSecret);
  
  // Namespace is automatically generated by server (no user input needed)
  
  // Add all available methods
  params.append('cmds', 'get_info,get,set,del,exists,mget,expire,ttl');
  
  // Add limits
  params.append('mps', config.limits.mps.toString());
  params.append('bps', config.limits.bps.toString());
  params.append('maxkey', config.limits.maxKey.toString());
  params.append('maxval', config.limits.maxVal.toString());
  params.append('mget_max', config.limits.mgetMax.toString());
  
  // Add name
  params.append('name', 'Test Connection');

  // Construct full URI (use hex for server pubkey too)
  const serverIdentifier = useHex ? serverKeyring.getPublicKey() : serverKeyring.getNpub();
  const uri = `nostr+kvconnect://${serverIdentifier}?${params.toString()}`;
  
  return uri;
}

export interface AppConnectionRequest {
  appName: string;
  methods: string[];
  limits: {
    mps: number;
    bps: number;
    maxkey: number;
    maxval: number;
    mget_max: number;
  };
}

/**
 * Generate a cryptographically secure unique namespace for an app
 * This ensures each app connection has its own isolated database
 */
function generateSecureNamespace(appName: string, clientPubkey: string): string {
  // Create a hash of app name + client pubkey for uniqueness
  const hash = crypto.createHash('sha256')
    .update(appName.toLowerCase().replace(/[^a-z0-9]/g, ''))
    .update(clientPubkey)
    .update(Date.now().toString()) // Add timestamp for additional uniqueness
    .digest('hex');
  
  // Take first 16 chars of hash for readability
  const uniqueId = hash.substring(0, 16);
  
  // Create namespace: app_name + unique_id
  const sanitizedAppName = appName.toLowerCase().replace(/[^a-z0-9]/g, '').substring(0, 32);
  return `${sanitizedAppName}_${uniqueId}:`;
}

/**
 * Validate app configuration for security
 */
function validateAppConfig(appConfig: AppConnectionRequest): { valid: boolean; error?: string } {
  // Validate app name
  if (!appConfig.appName || appConfig.appName.trim().length === 0) {
    return { valid: false, error: 'App name is required' };
  }
  
  if (appConfig.appName.length > 64) {
    return { valid: false, error: 'App name too long (max 64 chars)' };
  }
  
  // Check for malicious patterns in app name
  const maliciousPatterns = /[<>"'&\\$\(\)\{\}\[\]`]|javascript:|data:|vbscript:/i;
  if (maliciousPatterns.test(appConfig.appName)) {
    return { valid: false, error: 'App name contains invalid characters' };
  }
  
  // Validate methods
  const allowedMethods = ['get_info', 'get', 'set', 'del', 'exists', 'mget', 'expire', 'ttl'];
  for (const method of appConfig.methods) {
    if (!allowedMethods.includes(method)) {
      return { valid: false, error: `Invalid method: ${method}` };
    }
  }
  
  // Validate limits are reasonable
  if (appConfig.limits.mps < 1 || appConfig.limits.mps > 1000) {
    return { valid: false, error: 'MPS must be between 1 and 1000' };
  }
  
  if (appConfig.limits.bps < 1024 || appConfig.limits.bps > 10485760) { // 1KB to 10MB
    return { valid: false, error: 'BPS must be between 1KB and 10MB' };
  }
  
  return { valid: true };
}

export function generateCustomURI(config: Config, serverKeyring: Keyring, appConfig: AppConnectionRequest, useHex: boolean = true): { uri: string; clientKeyring: Keyring; namespace: string } {
  // Validate app configuration first
  const validation = validateAppConfig(appConfig);
  if (!validation.valid) {
    throw new Error(`Invalid app configuration: ${validation.error}`);
  }
  
  // Generate a client keypair for this app
  const clientKeyring = new Keyring();
  
  // Generate a secure, unique namespace for this app
  const secureNamespace = generateSecureNamespace(appConfig.appName, clientKeyring.getPublicKey());
  
  // Build URI components
  const params = new URLSearchParams();
  
  // Add relays from server config
  config.nostr.relays.forEach(relay => {
    params.append('relay', relay);
  });

  // Add client secret (use hex by default for better compatibility)
  const clientSecret = useHex ? bytesToHex(clientKeyring.getSecretKey()) : clientKeyring.getNsec();
  params.append('secret', clientSecret);
  
  // Namespace is automatically generated by server (not included in connection string)
  
  // Add custom methods
  params.append('cmds', appConfig.methods.join(','));
  
  // Add custom limits
  params.append('mps', appConfig.limits.mps.toString());
  params.append('bps', appConfig.limits.bps.toString());
  params.append('maxkey', appConfig.limits.maxkey.toString());
  params.append('maxval', appConfig.limits.maxval.toString());
  params.append('mget_max', appConfig.limits.mget_max.toString());
  
  // Add app name
  params.append('name', appConfig.appName);

  // Construct full URI (use hex for server pubkey too)
  const serverIdentifier = useHex ? serverKeyring.getPublicKey() : serverKeyring.getNpub();
  const uri = `nostr+kvconnect://${serverIdentifier}?${params.toString()}`;
  
  return { uri, clientKeyring, namespace: secureNamespace };
}

export function displayConnectionInfo(config: Config, serverKeyring: Keyring, testURI: string, webUrl?: string): void {
  console.log('\nüöÄ NostrKV Connect Server Started!');
  console.log('=====================================');
  console.log('');
  console.log('üì° Server Details:');
  console.log(`   Public Key: ${serverKeyring.getNpub()}`);
  console.log(`   Namespace:  ${config.redis.namespace}`);
  console.log(`   Redis URL:  ${config.redis.url}`);
  console.log(`   Relays:     ${config.nostr.relays.join(', ')}`);
  console.log('');
  console.log('üìä Limits:');
  console.log(`   Requests:   ${config.limits.mps}/minute`);
  console.log(`   Bandwidth:  ${formatBytes(config.limits.bps)}/minute`);
  console.log(`   Max Key:    ${config.limits.maxKey} chars`);
  console.log(`   Max Value:  ${formatBytes(config.limits.maxVal)}`);
  console.log('');
  
  if (webUrl) {
    console.log('=' .repeat(60));
    console.log('üåê WEB INTERFACE AVAILABLE!');
    console.log('=' .repeat(60));
    console.log('');
    console.log('üéØ OPEN THIS URL IN YOUR BROWSER:');
    console.log('');
    console.log(`   ‚û§  ${webUrl}`);
    console.log('');
    console.log('=' .repeat(60));
    console.log('');
    console.log('‚ú® Connection URI will be loaded automatically!');
    console.log('');
  } else {
    console.log('üîó Test Connection URI:');
    console.log('   Use this URI with the demo client or web interface:');
    console.log('');
    console.log(`   ${testURI}`);
    console.log('');
    console.log('üåê Web Interface:');
    console.log('   Static file: file://' + process.cwd() + '/web-test/index.html');
    console.log('   Or run: npm run web');
    console.log('');
  }
  
  console.log('‚ú® Ready for connections!');
  console.log('');
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}